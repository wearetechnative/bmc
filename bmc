#!/usr/bin/env bash

function is_sourced() {
  if [ -n "$ZSH_VERSION" ]; then
    case $ZSH_EVAL_CONTEXT in *:file:*) return 0;; esac
  else  # Add additional POSIX-compatible shell names here, if needed.
    case ${0##*/} in dash|-dash|bash|-bash|ksh|-ksh|sh|-sh) return 0;; esac
  fi
  return 1  # NOT sourced.
}

is_sourced && sourced=1 || sourced=0

if [ "$0" = "./bmc" ]
then
  echo "RUNNING IN DEVMODE"
  thisdir="$(dirname "$0")"
else
  if [ $sourced -eq 1 ]
  then
    thisdir="$(dirname "$(which bmc)")"
  else
    thisdir="$(dirname "$0")"
  fi
fi

# INCLUDE LIB
source "$thisdir/_bmclib.sh"

CMDS=()
DESC=()
NARGS=$#
ARG1=$1
shift
ARGREST=$@

make_command(){
  CMDS+=("$1")
  DESC+=("$2")
};

make_command "usage" "Show this help."
usage(){
  printf "\nUsage: %s [command]\n\nCommands:\n" $(basename $0);

  i=0
  for cmd in "${CMDS[@]}"
  do
    printf "  %-10s %-40s \n" ${cmd} "${DESC[$i]}";
    i=$((i + 1))
  done
};

runme(){
  if test $NARGS -ge 1;
  then eval "$ARG1" "$ARGREST" ||usage;
  else usage;
  fi;
}

function prelude(){
  loadConfig
  # CHECK deps
  checkdeps "jsonify-aws-dotfiles"
  checkdeps "jq"
  checkdeps "awk"
  checkdeps "assumego"
  checkdeps "gum"
  deps_missing
}

function AWSProfileOrExit(){

  if [ -z $AWS_PROFILE ]
  then
    echo "This command needs AWS_PROFILE to be set. run bmc profsel"
    exit 1
  fi
}

##### PLACE YOUR COMMANDS BELOW #####

make_command "version" "Show bmc version"
version(){
  show_version
}

make_command "profsel" "Set AWS_PROFILE by sourcing this command"
profsel(){

  prelude

  if [[ $# -gt 0 ]]; then
    while getopts 'lp:' opt; do
      case "$opt" in
        l)
          printAWSProfiles
          return
          ;;
        p)
          preferedProfile=$OPTARG
          ;;
        *)
          ;;
      esac
    done
    shift "$(($OPTIND - 1))"
  fi

  selectAWSProfile "$@"

  if [[ -z $selectedProfileName ]]; then
    echo "No profile selected"
    return
  fi

  setMFA

  if [ $sourced -eq 1 ]; then
    export AWS_PROFILE=${selectedProfileName}
  else
    echo "Source this script or copy/paste the line below to set profile:"
    echo
    echo "  export AWS_PROFILE=${selectedProfileName}"
    echo
  fi

}

make_command "console" "Open Firefox with AWS account in console."
console(){

  prelude

  forceProfileSelection=false
  if [[ $# -gt 0 ]]; then
    # Manual parsing to handle -p without value
    while [[ $# -gt 0 ]]; do
      case "$1" in
        -l)
          printAWSProfiles
          return
          ;;
        -p)
          shift
          # Check if next arg exists and doesn't start with -
          if [[ -n $1 && $1 != -* ]]; then
            preferedProfile="$1"
            shift
          else
            forceProfileSelection=true
          fi
          ;;
        -s)
          shift
          if [[ -n $1 ]]; then
            preferedService="$1"
            shift
          fi
          ;;
        *)
          shift
          ;;
      esac
    done
  fi

  # Use AWS_PROFILE if set and not forcing selection
  if [[ -n $AWS_PROFILE && $forceProfileSelection == false && -z $preferedProfile ]]; then
    selectedProfileName=$AWS_PROFILE
    # Determine sourceProfile from AWS_PROFILE for MFA
    selectedProfileARN=$(jsonify-aws-dotfiles | jq -r ".config.\"${AWS_PROFILE}\".role_arn")
    if [[ $selectedProfileARN != "null" && -n $selectedProfileARN ]]; then
      sourceProfile=$(jsonify-aws-dotfiles | jq -r --arg arn "$selectedProfileARN" '.config | to_entries | map(select(.value.role_arn == $arn)) | .[0].value.source_profile // "Error"')
      if [[ ${sourceProfile} == "Error" ]]; then
        sourceProfile=${selectedProfileName}
      fi
    else
      # Profile is in credentials, not config
      sourceProfile=${selectedProfileName}
    fi
  else
    selectAWSProfile
  fi

  setMFA

  GRANTED_ALIAS_CONFIGURED="true" GRANTED_ENABLE_AUTO_REASSUME=tru  assumego --duration 3600s -c $selectedProfileName ${preferedService:+--service "$preferedService"}
}

make_command "ec2ls" "List running ec2's."
ec2ls(){
  prelude
  useOrSelectAWSProfile
  ec2ListInstances
}

make_command "ec2connect" "connect to running ec2."
ec2connect(){
  prelude
  useOrSelectAWSProfile
  $thisdir/ec2connect.sh "$@"
}

make_command "ec2stopstart" "Stop/start ec2 instance"
ec2stopstart(){
  prelude
  useOrSelectAWSProfile
  ec2StopStartInstance "$@"
}

make_command "ec2find" "find ec2 instance"
ec2find(){
  prelude
  useOrSelectAWSProfile
  ec2FindInstance "$@"
}

make_command "ec2scheduler" "Toggle InstanceScheduler tag to enable/disable scheduling"
ec2scheduler(){
  prelude
  useOrSelectAWSProfile
  $thisdir/ec2scheduler.sh
}

make_command "ecsconnect" "shell connect to ecs container."
ecsconnect(){
  prelude
  useOrSelectAWSProfile
  $thisdir/ecsconnect.sh
}

make_command "gencompletions" "Generate shell completion scripts for bash or zsh"
gencompletions(){
  local shell_type="$1"

  if [[ -z "$shell_type" ]]; then
    echo "Error: Please specify shell type (bash or zsh)"
    echo "Usage: bmc gencompletions <bash|zsh>"
    exit 1
  fi

  case "$shell_type" in
    bash)
      cat << 'EOF'
# Bash completion for bmc command
_bmc_completion() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    # Get available commands dynamically from bmc usage output
    if [[ ${COMP_CWORD} -eq 1 ]]; then
        opts=$(bmc usage 2>/dev/null | awk 'NR>3 && NF>0 {print $1}')
        COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
        return 0
    fi
}

complete -F _bmc_completion bmc
EOF
      echo ""
      echo "# Installation instructions:"
      echo "# 1. Add to your ~/.bashrc:"
      echo "#    source <(bmc gencompletions bash)"
      echo "#"
      echo "# 2. Or save to a file and source it:"
      echo "#    bmc gencompletions bash > ~/.bmc-completion.bash"
      echo "#    echo 'source ~/.bmc-completion.bash' >> ~/.bashrc"
      echo "#"
      echo "# 3. Or install system-wide (requires root):"
      echo "#    bmc gencompletions bash | sudo tee /etc/bash_completion.d/bmc"
      echo "#"
      echo "# Then restart your shell or run: source ~/.bashrc"
      ;;
    zsh)
      cat << 'EOF'
#compdef bmc

# Zsh completion for bmc command
_bmc() {
    local -a commands
    local -a command_descriptions

    # Get available commands dynamically from bmc usage output
    local usage_output
    usage_output=$(bmc usage 2>/dev/null)

    # Parse commands and descriptions
    while IFS= read -r line; do
        if [[ $line =~ ^[[:space:]]+([a-z0-9_-]+)[[:space:]]+(.+)$ ]]; then
            local cmd="${match[1]}"
            local desc="${match[2]}"
            commands+=("$cmd")
            command_descriptions+=("$cmd:$desc")
        fi
    done <<< "$usage_output"

    if (( CURRENT == 2 )); then
        _describe 'bmc command' command_descriptions
    fi
}

_bmc "$@"
EOF
      echo ""
      echo "# Installation instructions:"
      echo "# 1. Add to your ~/.zshrc:"
      echo "#    source <(bmc gencompletions zsh)"
      echo "#"
      echo "# 2. Or save to a completion directory:"
      echo "#    mkdir -p ~/.zsh/completions"
      echo "#    bmc gencompletions zsh > ~/.zsh/completions/_bmc"
      echo "#    # Add to ~/.zshrc if not already present:"
      echo "#    fpath=(~/.zsh/completions \$fpath)"
      echo "#    autoload -Uz compinit"
      echo "#    compinit"
      echo "#"
      echo "# Then restart your shell or run: source ~/.zshrc"
      ;;
    *)
      echo "Error: Unsupported shell type '$shell_type'"
      echo "Supported shells: bash, zsh"
      exit 1
      ;;
  esac
}

##### PLACE YOUR COMMANDS ABOVE #####

runme
